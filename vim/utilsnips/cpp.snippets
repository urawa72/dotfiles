snippet comp "compro base"
#include <bits/stdc++.h>
using namespace std;

#define all(v) v.begin(), v.end()
typedef long long ll;
const int INT_INF = 1e9;
const ll INF = 1LL << 30;

int main() {
    ${1:Implement}
}
endsnippet

snippet in "cin"
cin >> ${1:Variant};
endsnippet

snippet in2 "cin"
cin >> ${1:Variant} >> ${2:Variant};
endsnippet

snippet op "cout with endl"
cout << ${1:Out} << endl;
endsnippet

snippet rep "for lower"
for(int ${1:Counter} = 0; $1 < ${2:Max}; $1++)${3:Implement}
endsnippet

snippet repe "for lower or equal to"
for(int ${1:Counter} = 0; $1 <= ${2:Max}; $1++)${3:Implement}
endsnippet

# gcd/lcm/chmax/chmin
snippet temp "compro templates"
template<typename T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }
template<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }
template<class T> void chmax(T& a, T b) { if(a < b) a = b; }
template<class T> void chmin(T& a, T b) { if(a > b) a = b; }
endsnippet

# 順列全探索
snippet nextp "next_permitation snippet"
    vector<int> nums(n);
    iota(nums.begin(), nums.end(), 1);
    do {
        printVec(nums);
    } while(next_permutation(nums.begin(), nums.end()));
endsnippet

# 深優先探索
snippet dfs "dfs snippet"
using Graph = vector<vector<int>>;
vector<bool> seen;
void dfs(const Graph &g, int v){
    seen[v] = true;
    for(auto next_v : g[v]){
        if(seen[next_v]) continue;
        dfs(g, next_v);
    }
}
endsnippet

# 素因数分解
snippet primef "prime factrize"
// const auto &pf = prime_factorize(N);
vector<pair<ll, ll> > prime_factorize(ll n){
    vector<pair<ll, ll> > res;
    for(ll i = 2; i * i <= n; i++){
        if(n % i != 0) continue;
        ll ex = 0;
        while(n % i == 0){
            ex++;
            n /= i;
        }
        res.push_back({i, ex});
    }
    if(n != 1) res.push_back({n, 1});
    return res;
}
endsnippet

